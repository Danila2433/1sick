#include <iostream>
#define n 5

using namespace std;

int c[n];           // номер хода, на котором посещается вершина
int path[n];        // номера посещаемых вершин
int v0 = 2;         // начальная вершина

int a[n][n] =       //матрица смежности
{
    0,1,1,0,0,
    1,0,0,1,0,
    1,0,1,0,0,
    0,1,1,0,1,
    0,0,1,1,0,
};

void printGam(void)
{
    int p;
    for (p = 0; p < n; p++)
        cout << path[p] << " ";
    cout << path[0];
    cout << endl;
}

//подпрограмма нахождения гамильтонова цикла
//k - номер прохода или количество найденных вершин пути, результат - массив path, возвращвет признак нахождения пути
bool gamilton(int k)
{
    //если граф неориентированный, то оба используемых элемента матрицы должны быть равны
    //если ориентированный, то, по идее, надо смотреть только a[path[k - 1]][v]
    int v;          //индекс вершины
    bool found = false;     //признак нахождения пути, сначала - не найдено
    for (v = 0; v < n && !found; v++) // обход матрицы по всем вершинам и пока не найден путь
    {
        //есть ли ребро между текущей вершиной и вершиной, найденной при предыдущем вызове
        if (a[v][path[k - 1]] || a[path[k - 1]][v])
        {
            if (k == n && v == v0)          //если обошли все вершины и дошли до начальной,
                found = 1;                     // то путь найден
            else
                if (c[v] == -1)             //формируем путь, если в вершине v еще не были
                {
                    c[v] = k;               //номер прохода
                    path[k] = v;            //занесение вершины в найденный путь
                    found = gamilton(k + 1);   //ищем следующую вершину
                    if (!found) c[v] = -1;     //если путь не найден, то помечаем текущую вершину, как непройденную
                }
                else
                    continue;               //если в вершине уже были, то на анализ следующей вершины
        }
    }   
    return found;                          //возвращаем нашли или нет
}

int main()
{
    int j;
    cout << "Gamilton's circle:\n";
    for (j = 0; j < n; j++)
        c[j] = -1;                          //помечаем, что все вершины не пройдены
    path[0] = v0;                           //начинаем путь с вершины v0
    c[v0] = v0;                             // и она пройдена
    if (gamilton(1))                        //ищем путь, начиная с прохода 1
        printGam();
    else
        cout << "No solutions\n";
}
